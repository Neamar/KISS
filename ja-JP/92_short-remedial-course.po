#
# AUTHOR <EMAIL@ADDRESS>, YEAR.
# Ryuunosuke Ayanokouzi <i38w7i3@yahoo.co.jp>, 2015.
#
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2013-12-30 17:37+0100\n"
"PO-Revision-Date: 2015-07-08 08:02+0900\n"
"Last-Translator: AYANOKOUZI, Ryuunosuke <i38w7i3@yahoo.co.jp>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: keyword
#, no-c-format
msgid "BIOS"
msgstr "BIOS"

#. Tag: keyword
#, no-c-format
msgid "Kernel"
msgstr "カーネル"

#. Tag: keyword
#, no-c-format
msgid "Unix"
msgstr "Unix"

#. Tag: keyword
#, no-c-format
msgid "Process"
msgstr "プロセス"

#. Tag: keyword
#, no-c-format
msgid "Hierarchy"
msgstr "階層構造"

#. Tag: keyword
#, no-c-format
msgid "Basic Commands"
msgstr "基本コマンド"

#. Tag: title
#, no-c-format
msgid "Short Remedial Course"
msgstr "簡単な補習講座"

#. Tag: para
#, no-c-format
msgid "Even though this book primarily targets administrators and “power-users”, we wouldn't like to exclude motivated beginners. This appendix will therefore be a crash-course describing the fundamental concepts involved in handling a Unix computer."
msgstr "この本は主として管理者と「パワーユーザ」を対象にしているとはいえ、やる気のある初心者を仲間はずれにしたくはありません。そのため、この付録は Unix コンピュータを取り扱う際に求められる基礎的な概念を説明する集中講座になるでしょう。"

#. Tag: title
#, no-c-format
msgid "Shell and Basic Commands"
msgstr "シェルと基本コマンド"

#. Tag: para
#, no-c-format
msgid "In the Unix world, every administrator has to use the command line sooner or later; for example, when the system fails to start properly and only provides a command-line rescue mode. Being able to handle such an interface, therefore, is a basic survival skill for these circumstances."
msgstr "Unix 世界では、管理者全員が遅かれ早かれコマンドラインを使わなければいけません; 例えば、システムが正常な起動に失敗して、コマンドラインのレスキューモードだけが提供される場合です。それゆえ、このような状況下ではコマンドラインインターフェースを取り扱う事が可能な事が基本的なサバイバル技術です。"

#. Tag: title
#, no-c-format
msgid "<emphasis>QUICK LOOK</emphasis> Starting the command interpreter"
msgstr "<emphasis>QUICK LOOK</emphasis> コマンドインタプリタの起動"

#. Tag: para
#, no-c-format
msgid "A command-line environment can be run from the graphical desktop, by an application known as a “terminal”, such as those found under the <menuchoice><guimenu>Applications</guimenu> <guisubmenu>Accessories</guisubmenu></menuchoice> menu for GNOME, and in <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> for KDE."
msgstr "コマンドライン環境はグラフィカルデスクトップから「端末」として知られるアプリケーションを使って実行可能です。「端末」は GNOME の場合 <menuchoice><guimenu>アプリケーション</guimenu> <guisubmenu>アクセサリ</guisubmenu></menuchoice> メニュー、KDE の場合 <menuchoice><guimenu>K</guimenu> <guisubmenu>アプリケーション</guisubmenu> <guisubmenu>システム</guisubmenu></menuchoice> の中にあります。"

#. Tag: para
#, no-c-format
msgid "This section only gives a quick peek at the commands. They all have many options not described here; accordingly, they also have abundant documentation in their respective manual pages."
msgstr "この説では、コマンドを簡単に見ていきます。すべてのコマンドは多くのオプションを持っていますが、ここでは説明しません; また、コマンドのマニュアルページには豊富な文書が用意されています。"

#. Tag: title
#, no-c-format
msgid "Browsing the Directory Tree and Managing Files"
msgstr "ディレクトリツリーの閲覧とファイル管理"

#. Tag: para
#, no-c-format
msgid "Once a session is open, the <command>pwd</command> command (which stands for <emphasis>print working directory</emphasis>) displays the current location in the filesystem. The current directory is changed with the <command>cd <replaceable>directory</replaceable></command> command (<command>cd</command> is for <emphasis>change directory</emphasis>). The parent directory is always called <literal>..</literal> (two dots), whereas the current directory is also known as <literal>.</literal> (one dot). The <command>ls</command> command allows <emphasis>listing</emphasis> the contents of a directory. If no parameters are given, it operates on the current directory."
msgstr "一度セッションが開始されたら、<command>pwd</command> コマンド (これは <emphasis>print working directory</emphasis> の略語です) でファイルシステム上の現在の場所を表示する事が可能です。現在のディレクトリを変更するには、<command>cd <replaceable>directory</replaceable></command> コマンド (<command>cd</command> は <emphasis>change directory</emphasis> の略語です) を使います。親ディレクトリは常に <literal>..</literal> (ドット 2 つ) で表します。これに対して、現在のディレクトリは <literal>.</literal> (ドット 1 つ) で表します。<command>ls</command> コマンドは指定したディレクトリの内容を <emphasis>listing (表示)</emphasis> します。パラメータを与えなかった場合、<command>ls</command> コマンドは現在のディレクトリの内容を表示します。"

#. Tag: screen
#, no-c-format
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>cd Desktop</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd .</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog/Desktop\n"
"$ </computeroutput><userinput>cd ..</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>pwd</userinput>\n"
"<computeroutput>/home/rhertzog\n"
"$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates\n"
"Documents  Music      Public    Videos</computeroutput>\n"
"      "

#. Tag: para
#, no-c-format
msgid "A new directory can be created with <command>mkdir <replaceable>directory</replaceable></command>, and an existing (empty) directory can be removed with <command>rmdir <replaceable>directory</replaceable></command>. The <command>mv</command> command allows <emphasis>moving</emphasis> and/or renaming files and directories; <emphasis>removing</emphasis> a file involves <command>rm <replaceable>file</replaceable></command>."
msgstr "新しいディレクトリを作成するには <command>mkdir <replaceable>directory</replaceable></command> を使い、既存の (空) ディレクトリを削除するには <command>rmdir <replaceable>directory</replaceable></command> を使います。<command>mv</command> コマンドを使うことでファイルとディレクトリの <emphasis>moving (移動)</emphasis> 及び名前変更が可能です; ファイルを <emphasis>removing (削除)</emphasis> するには <command>rm <replaceable>file</replaceable></command> を実行します。"

#. Tag: screen
#, no-c-format
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    test\n"
"$ </computeroutput><userinput>mv test new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  new       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public    test\n"
"$ </computeroutput><userinput>mv test new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  new       Public     Videos\n"
"Documents  Music      Pictures  Templates\n"
"$ </computeroutput><userinput>rmdir new</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>ls</userinput>\n"
"<computeroutput>Desktop    Downloads  Pictures  Templates  Videos\n"
"Documents  Music      Public</computeroutput>\n"
"      "

#. Tag: title
#, no-c-format
msgid "Displaying and Modifying Text Files"
msgstr "テキストファイルの表示と書き換え"

#. Tag: para
#, no-c-format
msgid "The <command>cat <replaceable>file</replaceable></command> command (intended to <emphasis>concatenate</emphasis> files on its standard output) reads a file and displays its contents in the terminal. If the file is too big to fit on a screen, use a pager such as <command>less</command> (or <command>more</command>) to display it page by page."
msgstr "<command>cat <replaceable>file</replaceable></command> コマンド (ファイルを標準出力に <emphasis>concatenate (連結)</emphasis> する) はファイルを読み込んで内容を端末に表示する。ファイルが画面上に表示するには大きすぎる場合、<command>less</command> (および <command>more</command>) などのページャーを使い、ページごとに内容を表示します。"

#. Tag: para
#, no-c-format
msgid "The <command>editor</command> command always points at a text editor (such as <command>vi</command> or <command>nano</command>) and allows creating, modifying and reading text files. The simplest files can sometimes be created directly from the command interpreter thanks to redirection: <command>echo \"<replaceable>text</replaceable>\" &gt;<replaceable>file</replaceable></command> creates a file named <replaceable>file</replaceable> with “<replaceable>text</replaceable>” as its contents. Adding a line at the end of this file is possible too, with a command such as <command>echo \"<replaceable>line</replaceable>\" &gt;&gt;<replaceable>file</replaceable></command>."
msgstr "<command>editor</command> コマンドは常にテキストエディタ (<command>vi</command> や <command>nano</command> など) を指しており、テキストファイルの作成、修正、読み込みを行います。リダイレクト機能のお陰で、しばしばコマンドインタプリタから最も簡単なファイルを作る事が可能です: <command>echo \"<replaceable>text</replaceable>\" &gt;<replaceable>file</replaceable></command> は「<replaceable>text</replaceable>」という内容で <replaceable>file</replaceable> と名付けられたファイルを作成します。<command>echo \"<replaceable>line</replaceable>\" &gt;&gt;<replaceable>file</replaceable></command> などのコマンドを使えば、ファイルの最後に行を追加する事も可能です。"

#. Tag: title
#, no-c-format
msgid "Searching for Files and within Files"
msgstr "ファイルとファイル内容の検索"

#. Tag: para
#, no-c-format
msgid "The <command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command> command looks for files in the hierarchy under <replaceable>directory</replaceable> according to several criteria. The most commonly used criterion is <literal>-name <replaceable>name</replaceable></literal>: it allows looking for a file by its name."
msgstr "<command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command> コマンドは <replaceable>directory</replaceable> の下にあるファイルから条件に一致するものを探します。最もよく使われる条件は <literal>-name <replaceable>name</replaceable></literal> です: これは名前を基にしてファイルを探します。"

#. Tag: para
#, no-c-format
msgid "The <command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command> command searches the contents of the files and extracts the lines matching the regular expression (see sidebar <xref linkend=\"sidebar.regexp\" />). Adding the <literal>-r</literal> option enables a recursive search on all files contained in the directory passed as a parameter. This allows looking for a file when only a part of the contents are known."
msgstr "<command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command> コマンドはファイルの内容を検索して、正規表現 (傍注<xref linkend=\"sidebar.regexp\" />参照) に一致する行を抽出します。<literal>-r</literal> オプションを追加すれば、パラメータとして指定されたディレクトリに含まれるすべてのファイルに対して再帰検索する事が可能です。<literal>-r</literal> オプションを使うことで、内容の一部がわかっているファイルを探す事が可能です。"

#. Tag: title
#, no-c-format
msgid "Managing Processes"
msgstr "プロセス管理"

#. Tag: para
#, no-c-format
msgid "The <command>ps aux</command> command lists the processes currently running and allows identifying them by their <emphasis>pid</emphasis> (process id). Once the <emphasis>pid</emphasis> of a process is known, the <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> command allows sending it a signal (if the process belongs to the current user). Several signals exist; most commonly used are <literal>TERM</literal> (a request to terminate) and <literal>KILL</literal> (a heavy-handed kill)."
msgstr "<command>ps aux</command> コマンドは現在実行中のプロセスをリストし、プロセスの <emphasis>pid</emphasis> (プロセス ID) を使ってプロセスを識別する事が可能です。プロセスの <emphasis>pid</emphasis> が判ったら、<command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> コマンドを使ってプロセスにシグナルを送信する事が可能です (対象のプロセスがシグナルを送信するユーザのものである場合に限ります)。シグナルには様々な種類があります; 最もよく使われるのが <literal>TERM</literal> (処理の終了を依頼する) と <literal>KILL</literal> (強制的に終了する)。"

#. Tag: para
#, no-c-format
msgid "The command interpreter can also run programs in the background if the command ends with “&amp;”. By using the ampersand, the user resumes control of the shell immediately even though the command is still running (hidden from the user; as a background process). The <command>jobs</command> command lists the processes running in the background; running <command>fg %<replaceable>job-number</replaceable></command> (for <emphasis>foreground</emphasis>) restores a job to the foreground. When a command is running in the foreground (either because it was started normally, or brought back to the foreground with <command>fg</command>), the <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo> key combination pauses the process and resumes control of the command-line. The process can then be restarted in the background with <command>bg %<replaceable>job-number</replaceable></command> (for <foreignphrase>background</foreignphrase>)."
msgstr "コマンドインタプリタは、コマンドの最後に「&amp;」がついていた場合、バックグラウンドでプログラムを実行します。アンパサンドを使うことで、ユーザは、コマンドがまだ実行中であっても、すぐにシェルの制御を再開する事が可能です (ここで実行したコマンドはユーザから見えなくなります; バックグラウンドプロセスになります)。<command>jobs</command> コマンドはバックグラウンドで実行中のプロセスをリストします; <command>fg %<replaceable>job-number</replaceable></command> (<emphasis>foreground</emphasis> の略語) は指定したジョブをフォアグラウンドに復活させます。コマンドがフォアグラウンドで実行されている場合 (通常通り開始した場合も、<command>fg</command> でフォアグラウンドに復活した場合も)、<keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo> キーの組み合わせでフォアグラウンドプロセスを一時停止してコマンドラインの制御を再開する事が可能です。プロセスをバックグラウンドで再開するには、<command>bg %<replaceable>job-number</replaceable></command> (<foreignphrase>background</foreignphrase> の略語) を使います。"

#. Tag: title
#, no-c-format
msgid "System Information: Memory, Disk Space, Identity"
msgstr "システム情報: メモリ、ディスク領域、識別情報"

#. Tag: para
#, no-c-format
msgid "The <command>free</command> command displays information on memory; <command>df</command> (<emphasis>disk free</emphasis>) reports on the available disk space on each of the disks mounted in the filesystem. Its <literal>-h</literal> option (for <emphasis>human readable</emphasis>) converts the sizes into a more legible unit (usually mebibytes or gibibytes). In a similar fashion, the <command>free</command> command understands the <literal>-m</literal> and <literal>-g</literal> options, and displays its data either in mebibytes or in gibibytes, respectively."
msgstr "<command>free</command> コマンドはメモリに関する情報を表示します; <command>df</command> (<emphasis>disk free</emphasis>) はファイルシステムにマウントされた各ディスクの利用可能なディスク領域を報告します。<literal>-h</literal> オプション (<emphasis>human readable</emphasis> の意味) はサイズを判りやすい単位 (通常メガバイトやギガバイト) で変換します。同様に、<command>free</command> コマンドに <literal>-m</literal> と <literal>-g</literal> オプションを渡した場合、データはそれぞれメガバイトかギガバイト単位で表示されます。"

#. Tag: screen
#, no-c-format
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on\n"
"/dev/sda2              9614084   4737916   4387796  52% /\n"
"tmpfs                   514208         0    514208   0% /lib/init/rw\n"
"udev                     10240       100     10140   1% /dev\n"
"tmpfs                   514208    269136    245072  53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380  83% /home\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>free</userinput>\n"
"<computeroutput>             total       used       free     shared    buffers     cached\n"
"Mem:       1028420    1009624      18796          0      47404     391804\n"
"-/+ buffers/cache:     570416     458004\n"
"Swap:      2771172     404588    2366584\n"
"$ </computeroutput><userinput>df</userinput>\n"
"<computeroutput>ファイルシス       1K-ブロック      使用    使用可 使用% マウント位置\n"
"/dev/sda2              9614084   4737916   4387796   52% /\n"
"tmpfs                   514208         0    514208    0% /lib/init/rw\n"
"udev                     10240       100     10140    1% /dev\n"
"tmpfs                   514208    269136    245072   53% /dev/shm\n"
"/dev/sda5             44552904  36315896   7784380   83% /home\n"
"</computeroutput>"

#. Tag: para
#, no-c-format
msgid "The <command>id</command> command displays the identity of the user running the session, along with the list of groups they belong to. Since access to some files or devices may be limited to group members, checking available group membership may be useful."
msgstr "<command>id</command> コマンドはセッションを実行しているユーザの識別情報をユーザが所属するグループのリストと一緒に表示します。一部のファイルやデバイスへのアクセスはグループメンバーだけに制限されているかもしれませんので、ユーザの所属するグループの確認する事が役に立つ場合があります。"

#. Tag: screen
#, no-c-format
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>id</userinput>\n"
"<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>\n"
"      "

#. Tag: title
#, no-c-format
msgid "Organization of the Filesystem Hierarchy"
msgstr "ファイルシステム階層の構成"

#. Tag: indexterm
#, no-c-format
msgid "<primary>Filesystem Hierarchy</primary>"
msgstr "<primary>ファイルシステム階層</primary>"

#. Tag: title
#, no-c-format
msgid "The Root Directory"
msgstr "ルートディレクトリ"

#. Tag: para
#, no-c-format
msgid "A Debian system is organized along the <emphasis>File Hierarchy Standard</emphasis> (FHS). This standard defines the purpose of each directory. For instance, the top-level directories are described as follows:"
msgstr "Debian システムは<emphasis>ファイルシステム階層標準</emphasis> (FHS) に沿って構成されています。ファイルシステム階層標準ではそれぞれのディレクトリの目的が定義されています。例えば、最上位ディレクトリに含まれるディレクトリの目的は以下のとおり定義されています:"

#. Tag: para
#, no-c-format
msgid "<filename>/bin/</filename>: basic programs;"
msgstr "<filename>/bin/</filename>: 基本プログラム;"

#. Tag: para
#, no-c-format
msgid "<filename>/boot/</filename>: Linux kernel and other files required for its early boot process;"
msgstr "<filename>/boot/</filename>: Linux カーネルと起動処理の初期に要求されるその他のファイル;"

#. Tag: para
#, no-c-format
msgid "<filename>/dev/</filename>: device files;"
msgstr "<filename>/dev/</filename>: デバイスファイル;"

#. Tag: para
#, no-c-format
msgid "<filename>/etc/</filename>: configuration files;"
msgstr "<filename>/etc/</filename>: 設定ファイル;"

#. Tag: para
#, no-c-format
msgid "<filename>/home/</filename>: user's personal files;"
msgstr "<filename>/home/</filename>: ユーザの個人ファイル;"

#. Tag: para
#, no-c-format
msgid "<filename>/lib/</filename>: basic libraries;"
msgstr "<filename>/lib/</filename>: 基本ライブラリ;"

#. Tag: para
#, no-c-format
msgid "<filename>/media/*</filename>: mount points for removable devices (CD-ROM, USB keys and so on);"
msgstr "<filename>/media/*</filename>: リムーバブルデバイス (CD-ROM、USB メモリなど) 用のマウントポイント;"

#. Tag: para
#, no-c-format
msgid "<filename>/mnt/</filename>: temporary mount point;"
msgstr "<filename>/mnt/</filename>: 一時的なマウントポイント;"

#. Tag: para
#, no-c-format
msgid "<filename>/opt/</filename>: extra applications provided by third parties;"
msgstr "<filename>/opt/</filename>: サードパーティが提供する追加アプリケーション;"

#. Tag: para
#, no-c-format
msgid "<filename>/root/</filename>: administrator's (root's) personal files;"
msgstr "<filename>/root/</filename>: 管理者 (root) の個人ファイル;"

#. Tag: para
#, no-c-format
msgid "<filename>/sbin/</filename>: system programs;"
msgstr "<filename>/sbin/</filename>: システムプログラム;"

#. Tag: para
#, no-c-format
msgid "<filename>/srv/</filename>: data used by servers hosted on this system;"
msgstr "<filename>/srv/</filename>: このシステムでホストされているサーバが使うデータ"

#. Tag: para
#, no-c-format
msgid "<filename>/tmp/</filename>: temporary files; this directory is often emptied at boot;"
msgstr "<filename>/tmp/</filename>: 一時ファイル; このディレクトリの内容は起動時に削除されます;"

#. Tag: para
#, no-c-format
msgid "<filename>/usr/</filename>: applications; this directory is further subdivided into <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (according to the same logic as in the root directory). Furthermore, <filename>/usr/share/</filename> contains architecture-independent data. <filename>/usr/local/</filename> is meant to be used by the administrator for installing applications manually without overwriting files handled by the packaging system (<command>dpkg</command>)."
msgstr "<filename>/usr/</filename>: アプリケーション; このディレクトリは <filename>bin</filename>、<filename>sbin</filename>、<filename>lib</filename> のようにさらに細分されます (各ディレクトリの目的はルートディレクトリにこれらのディレクトリが含まれる場合と同じです)。更に、<filename>/usr/share/</filename> にはアーキテクチャに依存しないデータが含まれます。<filename>/usr/local/</filename> は管理者が手作業でアプリケーションをインストールするために使われる事を意味します。こうすることで、パッケージ化システム (<command>dpkg</command>) によって取り扱われるファイルを上書きしなくても済むようになります。"

#. Tag: para
#, no-c-format
msgid "<filename>/var/</filename>: variable data handled by daemons. This includes log files, queues, spools, caches and so on."
msgstr "<filename>/var/</filename>: デーモンの取り扱う可変データ。これには、ログファイル、キュー、スプール、キャッシュなどが含まれます。"

#. Tag: para
#, no-c-format
msgid "<filename>/proc/</filename> and <filename>/sys/</filename> are specific to the Linux kernel (and not part of the FHS). They are used by the kernel for exporting data to user-space."
msgstr "<filename>/proc/</filename> と <filename>/sys/</filename> は Linux カーネルに特有のディレクトリです (FHS で定義されていません)。カーネルはユーザ空間にデータを書き出すためにこれらのディレクトリを使います。"

#. Tag: title
#, no-c-format
msgid "The User's Home Directory"
msgstr "ユーザのホームディレクトリ"

#. Tag: para
#, no-c-format
msgid "The contents of a user's home directory is not standardized, but there are still a few noteworthy conventions. One is that a user's home directory is often referred to by a tilde (“~”). That is useful to know because command interpreters automatically replace a tilde with the correct directory (usually <filename>/home/<replaceable>user</replaceable>/</filename>)."
msgstr "ユーザのホームディレクトリの内容は標準化されていませんが、特筆すべき規則が存在します。1 つ目は、ユーザのホームディレクトリがチルダ (「~」) で表される場合が多いという事です。これを知っておくと便利です。なぜなら、コマンドラインインタプリタは自動的にチルダを正しいディレクトリ (通常 <filename>/home/<replaceable>user</replaceable>/</filename>) に置き換えるからです。"

#. Tag: para
#, no-c-format
msgid "Traditionally, application configuration files are often stored directly under the user's home directory, but their names usually start with a dot (for instance, the <command>mutt</command> email client stores its configuration in <filename>~/.muttrc</filename>). Note that filenames that start with a dot are hidden by default; and <command>ls</command> only lists them when the <literal>-a</literal> option is used, and graphical file managers need to be told to display hidden files."
msgstr "伝統的に、アプリケーション設定ファイルはユーザのホームディレクトリの下に直接保存されている場合が多く、設定ファイルの名前は通常ドットで始まります (例えば、<command>mutt</command> 電子メールクライアントの設定は <filename>~/.muttrc</filename> に保存されます)。ドットで始まるファイル名はデフォルトで隠されることに注意してください; <command>ls</command> でドットで始まるファイル名を持つファイルを表示するには、<literal>-a</literal> オプションをつけてください。グラフィカルファイルマネージャで隠しファイルを表示するには、それぞれのアプリケーションの設定を変更してください。"

#. Tag: para
#, no-c-format
msgid "Some programs also use multiple configuration files organized in one directory (for instance, <filename>~/.ssh/</filename>). Some applications (such as the Iceweasel web browser) also use their directory to store a cache of downloaded data. This means that those directories can end up using a lot of disk space."
msgstr "一部のプログラムは 1 つのディレクトリに含まれる複数の設定ファイルを使用します (例えば、<filename>~/.ssh/</filename>)。また、一部のアプリケーション (Iceweasel ウェブブラウザなど) は自分の設定ディレクトリをダウンロードデータをキャッシュする目的で使います。これはアプリケーション設定ディレクトリが大量のディスク領域を消費する場合がある事を意味します。"

#. Tag: para
#, no-c-format
msgid "These configuration files stored directly in a user's home directory, often collectively referred to as <emphasis>dotfiles</emphasis>, have long proliferated to the point that these directories can be quite cluttered with them. Fortunately, an effort led collectively under the FreeDesktop.org umbrella has resulted in the “XDG Base Directory Specification”, a convention that aims at cleaning up these files and directory. This specification states that configuration files should be stored under <filename>~/.config</filename>, cache files under <filename>~/.cache</filename>, and application data files under <filename>~/.local</filename> (or subdirectories thereof). This convention is slowly gaining traction, and several applications (especially graphical ones) have started following it."
msgstr "これらの設定ファイルはユーザのホームディレクトリに直接保存され、まとめて<emphasis>ドットファイル</emphasis>と呼ばれており、増え続けることでユーザのホームディレクトリを散らからせる原因となっています。幸いなことに、FreeDesktop.org の傘下で行われた努力により「XDG 基本ディレクトリ仕様」が生まれました。これは設定ファイルと設定ディレクトリを一掃する事を目的とする仕様です。XDG 基本ディレクトリ仕様によれば、設定ファイルは <filename>~/.config</filename> に、キャッシュファイルは <filename>~/.cache</filename> に、アプリケーションデータファイルは <filename>~/.local</filename> (およびそのサブディレクトリ) に保存すると決められています。XDG 基本ディレクトリ仕様はゆっくりと勢いを増しつつあり、一部のアプリケーション (特にグラフィカルアプリケーション) はこの仕様に従うようになっています。"

#. Tag: para
#, no-c-format
msgid "Graphical desktops usually display the contents of the <filename>~/Desktop/</filename> directory (or whatever the appropriate translation is for systems not configured in English) on the desktop (ie, what's visible on screen once all applications are closed or iconized)."
msgstr "通常グラフィカルデスクトップは <filename>~/Desktop/</filename> ディレクトリ (または英語で設定されていないシステムの場合、適切に翻訳された名前のディレクトリ) の内容をデスクトップ (つまり、すべてのアプリケーションを閉じるかアイコン化した時の画面の内容) に表示します。"

#. Tag: para
#, no-c-format
msgid "Finally, the email system sometimes stores incoming emails into a <filename>~/Mail/</filename> directory."
msgstr "最後に、電子メールシステムは受信した電子メールを <filename>~/Mail/</filename> ディレクトリに保存する場合があります。"

#. Tag: title
#, no-c-format
msgid "Inner Workings of a Computer: the Different Layers Involved"
msgstr "コンピュータ内部の仕組み: 様々な層の関係性"

#. Tag: para
#, no-c-format
msgid "A computer is often considered as something rather abstract, and the externally visible interface is much simpler than its internal complexity. Such complexity comes in part from the number of pieces involved. However, these pieces can be viewed in layers, where a layer only interacts with those immediately above or below."
msgstr "コンピュータは抽象的なものとして考えられる場合が多く、外から見えるインターフェースは内部の複雑さに比べてずっと簡単なものです。この複雑さの原因は関連する要素が多い事です。しかしながら、これらの要素は層状構造をしており、ある層が影響を及ぼしたり影響を受けたりするその層の真上と真下の層だけです。"

#. Tag: para
#, no-c-format
msgid "An end-user can get by without knowing these details… as long as everything works. When confronting a problem such as, “The internet doesn't work!”, the first thing to do is to identify in which layer the problem originates. Is the network card (hardware) working? Is it recognized by the computer? Does the Linux kernel see it? Are the network parameters properly configured? All these questions isolate an appropriate layer and focus on a potential source of the problem."
msgstr "すべてが上手く動作している限り… エンドユーザは各層の詳細を理解する必要はありません。「インターネットに繋がらない!」などの問題に直面した場合、最初に問題の原因になっている層を特定する事が重要です。ネットワークカード (ハードウェア) は動いていますか? コンピュータはネットワークカードを認識していますか? Linux カーネルはネットワークカードを認識していますか? ネットワークパラメータは適切に設定されていますか? これらの質問により、コンピュータは適切な層に分割され、問題の本質的な原因になっている層を特定する事が可能です。"

#. Tag: title
#, no-c-format
msgid "The Deepest Layer: the Hardware"
msgstr "最下層: ハードウェア"

#. Tag: indexterm
#, no-c-format
msgid "<primary>IDE</primary>"
msgstr "<primary>IDE</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>SCSI</primary>"
msgstr "<primary>SCSI</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>Serial ATA</primary>"
msgstr "<primary>シリアル ATA</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>Parallel ATA</primary>"
msgstr "<primary>パラレル ATA</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>ATA</primary>"
msgstr "<primary>ATA</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>Firewire</primary>"
msgstr "<primary>Firewire</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

#. Tag: para
#, no-c-format
msgid "Let us start with a basic reminder that a computer is, first and foremost, a set of hardware elements. There is generally a main board (known as the <emphasis>motherboard</emphasis>), with one (or more) processor(s), some RAM, device controllers, and extension slots for option boards (for other device controllers). Most noteworthy among these controllers are IDE (Parallel ATA), SCSI and Serial ATA, for connecting to storage devices such as hard disks. Other controllers include USB, which is able to host a great variety of devices (ranging from webcams to thermometers, from keyboards to home automation systems) and IEEE 1394 (Firewire). These controllers often allow connecting several devices so the complete subsystem handled by a controller is therefore usually known as a “bus”. Option boards include graphics cards (where monitor screens will be plugged in to), sound cards, network interface cards, and so on. Some main boards are pre-built with these features, and don't need option boards."
msgstr "基本的な事を思い出すことからはじめましょう。何よりもまず、コンピュータはハードウェア部品の集合体である、という点です。ほとんどの場合主要基板 (<emphasis>マザーボード</emphasis>として知られています) があり、これには 1 台 (または複数台) のプロセッサ、RAM、デバイスコントローラ、(他のデバイスコントローラを搭載する) 拡張ボード用の拡張スロットが取り付けられています。特に注意すべきコントローラはハードディスクなどのストレージデバイスを接続する IDE (パラレル ATA)、SCSI、シリアル ATA、です。その他のコントローラには、多くの様々なデバイス (ウェブカメラから温度計、キーボードからホームオートメーションシステム) をホストする事が可能な USB と IEEE 1394 (Firewire) があります。これらのコントローラには複数のデバイスを接続する事が可能です。このため、コントローラによって取り扱われる完全なサブシステムは「バス」と呼ばれます。拡張ボードには、グラフィックカード (モニタ画面をここに接続します)、サウンドカード、ネットワークインターフェースカード、などがあります。一部のマザーボードはいくつかの機能を予め備えており、拡張カードを必要としません。"

#. Tag: title
#, no-c-format
msgid "<emphasis>IN PRACTICE</emphasis> Checking that the hardware works"
msgstr "<emphasis>IN PRACTICE</emphasis> ハードウェアが動作していることの確認"

#. Tag: para
#, no-c-format
msgid "Checking that a piece of hardware works can be tricky. On the other hand, proving that it doesn't work is sometimes quite simple."
msgstr "ハードウェアの一部が動作している事を確認することは難しいです。逆に、ハードウェアが動作していない事を証明することはとても簡単です。"

#. Tag: para
#, no-c-format
msgid "A hard disk drive is made of spinning platters and moving magnetic heads. When a hard disk is powered up, the platter motor makes a characteristic whir. It also dissipates energy as heat. Consequently, a hard disk drive that stays cold and silent when powered up is broken."
msgstr "ハードディスクドライブは回転する円盤と移動する磁気ヘッドから構成されています。ハードディスクの電源を入れると、円盤モータから特徴的な音が聞こえます。さらに円盤モータはエネルギーを熱として放出します。したがって、電源を入れても冷たいままで、音が聞こえないハードディスクドライブは故障しています。"

#. Tag: para
#, no-c-format
msgid "Network cards often include LEDs displaying the state of the link. If a cable is plugged in and leads to a working network hub or switch, at least one LED will be on. If no LED lights up, either the card itself, the network device, or the cable between them, is faulty. The next step is therefore testing each component individually."
msgstr "ネットワークカードは多くの場合リンク状態を示す LED を備えています。ケーブルが装着されており、そのケーブルが動いているネットワークハブまたはスイッチにつなげられている場合、少なくとも 1 つの LED が点灯しているはずです。すべての LED が消灯している場合、ネットワークカード本体、ネットワーク機器、両者をつなげるケーブルが壊れています。それ故、次の段階では各要素を個別にテストします。"

#. Tag: para
#, no-c-format
msgid "Some option boards — especially 3D video cards — include cooling devices, such as heat sinks and/or fans. If the fan does not spin even though the card is powered up, a plausible explanation is the card overheated. This also applies to the main processor(s) located on the main board."
msgstr "一部のオプションボード - 特に 3D ビデオカード - はヒートシンクやファンなどの冷却装置を備えています。カードの電源が入っているにも関わらずファンが回転していない場合、もっともらしい状況はカードが過熱している状況です。マザーボードに装着されているプロセッサにも同じ事が言えます。"

#. Tag: title
#, no-c-format
msgid "The Starter: the BIOS"
msgstr "スタート係: BIOS"

#. Tag: indexterm
#, no-c-format
msgid "<primary>BIOS</primary>"
msgstr "<primary>BIOS</primary>"

#. Tag: para
#, no-c-format
msgid "Hardware, on its own, is unable to perform useful tasks without a corresponding piece of software driving it. Controlling and interacting with the hardware is the purpose of the operating system and applications. These, in turn, require functional hardware to run."
msgstr "ハードウェアを制御するソフトウェアがなければ、ハードウェアをまともに動作させることはできません。オペレーティングシステムとアプリケーションは、ハードウェアを制御したりハードウェアと情報をやりとりする機能を提供します。同様に、これを行うためにはハードウェアを正常に機能させる必要があります。"

#. Tag: para
#, no-c-format
msgid "This symbiosis between hardware and software does not happen on its own. When the computer is first powered up, some initial setup is required. This role is assumed by the BIOS, a tiny piece of software embedded into the main board that runs automatically upon power-up. Its primary task is searching for software it can hand over control to. Usually, this involves looking for the first hard disk with a boot sector (also known as the <emphasis>master boot record</emphasis> or <acronym>MBR</acronym>), loading that boot sector, and running it. From then on, the BIOS is usually not involved (until the next boot)."
msgstr "ハードウェアとソフトウェアの共生関係はひとりでに発生するものではありません。コンピュータ起動時には、いくつかの初期設定が必要です。この初期設定を担当するのが BIOS です。BIOS はマザーボードに組み込まれた小さなソフトウェアで、起動中に自動的に実行されます。BIOS の最も重要な役割に、ハードウェアの制御を引き継ぐソフトウェアを検索する役割があります。通常、これはブートセクタ (<emphasis>マスターブートレコード</emphasis>や <acronym>MBR</acronym> として知られています) を備えた最初のハードディスクを検索し、ブートセクタを読み込んで、ブートセクタに収められているソフトウェアを実行します。BIOS の関与する動作はここまでです (次回起動時まで関与しません)。"

#. Tag: title
#, no-c-format
msgid "<emphasis>TOOL</emphasis> Setup, the BIOS configuration tool"
msgstr "<emphasis>TOOL</emphasis> Setup、BIOS 設定ツール"

#. Tag: indexterm
#, no-c-format
msgid "<primary><emphasis>Setup</emphasis></primary>"
msgstr "<primary><emphasis>Setup</emphasis></primary>"

#. Tag: para
#, no-c-format
msgid "The BIOS also contains a piece of software called Setup, designed to allow configuring aspects of the computer. In particular, it allows choosing which boot device is preferred (for instance, the floppy disk or CD-ROM drive), setting the system clock, and so on. Starting Setup usually involves pressing a key very soon after the computer is powered on. This key is often <keycap>Del</keycap> or <keycap>Esc</keycap>, sometimes <keycap>F2</keycap> or <keycap>F10</keycap>. Most of the time, the choice is flashed on screen while booting."
msgstr "BIOS には、Setup と呼ばれるソフトウェアが含まれます。Setup はコンピュータを設定する目的で設計されています。特に、Setup を使うことで優先する起動デバイス (例えば、フロッピーディスクや CD-ROM ドライブなど) を選択したり、システム時計を設定したりする事が可能です。Setup を開始するには、コンピュータ起動直後の非常に早い時期に特定のキーを押します。多くの場合このキーは <keycap>Del</keycap> か <keycap>Esc</keycap> で、時々 <keycap>F2</keycap> や <keycap>F10</keycap> の場合もあります。ほとんどの場合、Setup を開始するキーは起動画面に一瞬表示されます。"

#. Tag: para
#, no-c-format
msgid "The boot sector, in turn, contains another tiny piece of software, called the bootloader, whose purpose is to find and run an operating system. Since this bootloader is not embedded in the main board but loaded from disk, it can be smarter than the BIOS, which explains why the BIOS does not load the operating system by itself. For instance, the bootloader (often GRUB on Linux systems) can list the available operating systems and ask the user to choose one. Usually, a time-out and default choice is provided. Sometimes the user can also choose to add parameters to pass to the kernel, and so on. Eventually, a kernel is found, loaded into memory, and executed."
msgstr "ブートセクタには、別の小さなソフトウェアが含まれます。これはブートローダと呼ばれ、オペレーティングシステムを探して実行するためのものです。ブートローダはマザーボードに組み込まれているのではなく、ディスクから読み込まれます。このため、BIOS よりも多くの機能を持っています。BIOS 自身がオペレーティングシステムを読み込まないのはこれが理由です。例えば、ブートローダ (Linux システムでは GRUB を使う事が多いです) は利用可能なオペレーティングシステムを表示し、ユーザに起動するオペレーティングシステムを尋ねる事が可能です。通常、タイムアウトとデフォルトの回答が設定されています。ここでユーザはカーネルに渡すパラメータを追加したりする事も可能です。最終的に、カーネルが見つかり、メモリに読み込まれ、実行されます。"

#. Tag: para
#, no-c-format
msgid "The BIOS is also in charge of detecting and initializing a number of devices. Obviously, this includes the IDE/SATA devices (usually hard disk(s) and CD/DVD-ROM drives), but also PCI devices. Detected devices are often listed on screen during the boot process. If this list goes by too fast, use the <keycap>Pause</keycap> key to freeze it for long enough to read. Installed PCI devices that don't appear are a bad omen. At worst, the device is faulty. At best, it is merely incompatible with the current version of the BIOS or main board. PCI specifications evolve, and old main boards are not guaranteed to handle newer PCI devices."
msgstr "さらに BIOS は多数のデバイスを検出して初期化します。言うまでもなくこのデバイスには、IDE/SATA デバイス (通常ハードディスクおよび CD/DVD-ROM デバイス) だけでなく PCI デバイスも含まれます。検出されたデバイスは起動処理中に画面に表示されます。デバイスリストがすぐに消えてしまう場合、<keycap>Pause</keycap> キーを押せば表示を止めて内容を読む事が可能です。インストールされた PCI デバイスがリストに含まれないのは悪い兆しです。最悪の場合、デバイスは欠陥品ということになります。良くても、デバイスは BIOS かマザーボードの現在のバージョンと互換性が無いということになります。PCI 仕様は進化しており、古いマザーボードで新しい PCI デバイスを使える保証はありません。"

#. Tag: title
#, no-c-format
msgid "The Kernel"
msgstr "カーネル"

#. Tag: para
#, no-c-format
msgid "Both the BIOS and the bootloader only run for a few seconds each; now we're getting to the first piece of software that runs for a longer time, the operating system kernel. This kernel assumes the role of a conductor in an orchestra, and ensures coordination between hardware and software. This role involves several tasks including: driving hardware, managing processes, users and permissions, the filesystem, and so on. The kernel provides a common base to all other programs on the system."
msgstr "BIOS とブートローダはそれぞれ数秒間だけ実行されます; これでついに、長時間実行するソフトウェア、オペレーティングシステムカーネル、に到達します。カーネルはオーケストラの指揮者の役割を果たし、ハードウェアとソフトウェア間の調整を行います。カーネルは複数の仕事を担当しています: ハードウェアの駆動、プロセスの管理、ユーザとパーミッション、ファイルシステム、などです。カーネルはシステム上のすべての他のプログラムに共通基盤を提供します。"

#. Tag: title
#, no-c-format
msgid "The User Space"
msgstr "ユーザ空間"

#. Tag: para
#, no-c-format
msgid "Although everything that happens outside of the kernel can be lumped together under “user-space”, we can still separate it into software layers. However, their interactions are more complex than before, and the classifications may not be as simple. An application commonly uses libraries, which in turn involve the kernel, but the communications can also involve other programs, or even many libraries calling each other."
msgstr "カーネルの以外のすべては「ユーザ空間」の意味でひとくくりにされますが、「ユーザ空間」を更にいくつかのソフトウェア層に分割する事が可能です。しかしながら、ソフトウェア層同士の相互作用は以前に比べてさらに複雑化しており、ソフトウェア層の分類分けは単純ではありません。アプリケーションは一般にライブラリを使います。ライブラリはカーネルと通信しますが、通信には他のプログラムまたはさらに多くのライブラリが必要です。"

#. Tag: title
#, no-c-format
msgid "Some Tasks Handled by the Kernel"
msgstr "カーネルが担当する一部の操作"

#. Tag: title
#, no-c-format
msgid "Driving the Hardware"
msgstr "ハードウェアの操作"

#. Tag: para
#, no-c-format
msgid "The kernel is, first and foremost, tasked with controlling the hardware parts, detecting them, switching them on when the computer is powered on, and so on. It also makes them available to higher-level software with a simplified programming interface, so applications can take advantage of devices without having to worry about details such as which extension slot the option board is plugged into. The programming interface also provides an abstraction layer; this allows video-conferencing software, for example, to use a webcam independently of its make and model. The software can just use the <emphasis>Video for Linux</emphasis> (V4L) interface, and the kernel translates the function calls of this interface into the actual hardware commands needed by the specific webcam in use."
msgstr "カーネルの第一義はハードウェア部分を制御すること、検知すること、コンピュータが起動された時に切り替える事です。更にカーネルは単純化されたプログラミングインターフェースを使った高レベルソフトウェアからのハードウェアの利用を可能にします。こうすることで、アプリケーションは拡張ボードがどの拡張スロットに接続されているかなどの詳細を気にすることなくデバイスを上手く活用する事が可能になります。更にこのプログラミングインターフェースは抽象化レイヤを提供します; 抽象化レイヤを使うことで、例えばビデオ会議ソフトは種類やモデル番号を気にせずにウェブカメラを使う事が可能です。ビデオ会議ソフトは <emphasis>Video for Linux</emphasis> (V4L) を使うだけです。カーネルが V4L インターフェースの機能呼び出しを特定のウェブカメラを制御するために必要な実際のハードウェアコマンドに変換します。"

#. Tag: para
#, no-c-format
msgid "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> The kernel exports many details about detected hardware through the <filename>/proc/</filename> and <filename>/sys/</filename> virtual filesystems. Several tools summarize those details. Among them, <command>lspci</command> (in the <emphasis role=\"pkg\">pciutils</emphasis> package) lists PCI devices, <command>lsusb</command> (in the <emphasis role=\"pkg\">usbutils</emphasis> package) lists USB devices, and <command>lspcmcia</command> (in the <emphasis role=\"pkg\">pcmciautils</emphasis> package) lists PCMCIA cards. These tools are very useful for identifying the exact model of a device. This identification also allows more precise searches on the web, which in turn, lead to more relevant documents."
msgstr "<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> カーネルは検出されたハードウェアに関する多くの詳細を <filename>/proc/</filename> と <filename>/sys/</filename> 仮想ファイルシステムを通じて書き出します。ハードウェアの詳細をまとめて表示するツールも存在します。中でも、<command>lspci</command> (<emphasis role=\"pkg\">pciutils</emphasis> パッケージに含まれます) は PCI デバイスをリストし、<command>lsusb</command> (<emphasis role=\"pkg\">usbutils</emphasis> パッケージに含まれます) は USB デバイスをリストし、<command>lspcmcia</command> (<emphasis role=\"pkg\">pcmciautils</emphasis> パッケージに含まれます) は PCMCIA カードをリストします。これらのツールはデバイスの正確なモデル番号を識別するのに役立ちます。デバイスの正確なモデル番号を使えば、より的確に検索したり、より関連性の高い文書を見つける事が可能です。"

#. Tag: title
#, no-c-format
msgid "Example of information provided by <command>lspci</command> and <command>lsusb</command>"
msgstr "<command>lspci</command> と <command>lsusb</command> で提供される情報の例"

#. Tag: screen
#, no-c-format
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>lspci</userinput>\n"
"<computeroutput>[...]\n"
"00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)\n"
"00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)\n"
"00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)\n"
"[...]\n"
"01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)\n"
"02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)\n"
"$ </computeroutput><userinput>lsusb</userinput>\n"
"<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.\n"
"Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.\n"
"Bus 005 Device 007: ID 045e:00dd Microsoft Corp.\n"
"Bus 005 Device 006: ID 046d:c03d Logitech, Inc.\n"
"[...]\n"
"Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth\n"
"</computeroutput>"

#. Tag: para
#, no-c-format
msgid "These programs have a <literal>-v</literal> option, that lists much more detailed (but usually not necessary) information. Finally, the <command>lsdev</command> command (in the <emphasis role=\"pkg\">procinfo</emphasis> package) lists communication resources used by devices."
msgstr "これらのプログラムは <literal>-v</literal> オプションを取ります。<literal>-v</literal> オプションを使うことで、より詳しい (通常は不要な) 情報が表示されます。最後に、<command>lsdev</command> コマンド (<emphasis role=\"pkg\">procinfo</emphasis> に含まれます) はデバイスによって使われている通信リソースをリストします。"

#. Tag: para
#, no-c-format
msgid "Applications often access devices by way of special files created within <filename>/dev/</filename> (see sidebar <xref linkend=\"sidebar.special-files\" />). These are special files that represent disk drives (for instance, <filename>/dev/hda</filename> and <filename>/dev/sdc</filename>), partitions (<filename>/dev/hda1</filename> or <filename>/dev/sdc3</filename>), mice (<filename>/dev/input/mouse0</filename>), keyboards (<filename>/dev/input/event0</filename>), soundcards (<filename>/dev/snd/*</filename>), serial ports (<filename>/dev/ttyS*</filename>), and so on."
msgstr "アプリケーションは <filename>/dev/</filename> 内に作られた特殊ファイルを介してデバイスにアクセスする場合が多いです (傍注<xref linkend=\"sidebar.special-files\" />参照)。<filename>/dev/</filename> 内には特殊ファイルがあり、これらはディスクドライブ (例えば、<filename>/dev/hda</filename> や <filename>/dev/sdc</filename>)、パーティション (<filename>/dev/hda1</filename> や <filename>/dev/sdc3</filename>)、その他 (<filename>/dev/input/mouse0</filename>)、キーボード (<filename>/dev/input/event0</filename>)、サウンドカード (<filename>/dev/snd/*</filename>)、シリアルポート (<filename>/dev/ttyS*</filename>)、などを表します。"

#. Tag: title
#, no-c-format
msgid "Filesystems"
msgstr "ファイルシステム"

#. Tag: indexterm
#, no-c-format
msgid "<primary>filesystem</primary>"
msgstr "<primary>ファイルシステム</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>system, filesystem</primary>"
msgstr "<primary>システム、ファイルシステム</primary>"

#. Tag: para
#, no-c-format
msgid "Filesystems are one of the most prominent aspects of the kernel. Unix systems merge all the file stores into a single hierarchy, which allows users (and applications) to access data simply by knowing its location within that hierarchy."
msgstr "ファイルシステムはカーネルの最も目立つ側面の 1 つです。Unix システムはすべてのファイルを統合し、1 つの階層構造の中に保存します。こうすることで、ユーザ (とアプリケーション) は階層構造の中のファイルの場所を知るだけでデータにアクセスする事が可能です。"

#. Tag: para
#, no-c-format
msgid "The starting point of this hierarchical tree is called the root, <filename>/</filename>. This directory can contain named subdirectories. For instance, the <literal>home</literal> subdirectory of <filename>/</filename> is called <filename>/home/</filename>. This subdirectory can, in turn, contain other subdirectories, and so on. Each directory can also contain files, where the actual data will be stored. Thus, the <filename>/home/rmas/Desktop/hello.txt</filename> name refers to a file named <literal>hello.txt</literal> stored in the <literal>Desktop</literal> subdirectory of the <literal>rmas</literal> subdirectory of the <literal>home</literal> directory present in the root. The kernel translates between this naming system and the actual, physical storage on a disk."
msgstr "階層構造ツリーの起点はルート、<filename>/</filename>、と呼ばれています。ルートディレクトリには名前を付けられたサブディレクトリが含まれます。例えば、<filename>/</filename> の <literal>home</literal> サブディレクトリは <filename>/home/</filename> と呼ばれます。このサブディレクトリには、更に別のサブディレクトリを含める事が可能です。各ディレクトリには、実際のデータが保存されるファイルを含める事も可能です。そんなわけで、<filename>/home/rmas/Desktop/hello.txt</filename> ファイルはルートディレクトリ内の <literal>home</literal> サブディレクトリ内の <literal>rmas</literal> サブディレクトリ内の <literal>Desktop</literal> サブディレクトリ内の <literal>hello.txt</literal> と名付けられたファイルを表します。カーネルはこの命名システムと実際のディスク上の物理的な保存領域を変換します。"

#. Tag: para
#, no-c-format
msgid "Unlike other systems, there's only one such hierarchy, and it can integrate data from several disks. One of these disks is used as the root, and the others are “mounted” on directories in the hierarchy (the Unix command is called <command>mount</command>); these other disks are then available under these “mount points”. This allows storing users' home directories (traditionally stored within <filename>/home/</filename>) on a second hard disk, which will contain the <literal>rhertzog</literal> and <literal>rmas</literal> directories. Once the disk is mounted on <filename>/home/</filename>, these directories become accessible at their usual locations, and paths such as <filename>/home/rmas/Desktop/hello.txt</filename> keep working."
msgstr "他のシステムと異なり、このような階層構造は一つしかありません。そしてこの単独の階層構造に複数のディスクからのデータを統合できます。1 台のディスクがルートディレクトリとして使われ、他のディスクは階層構造中のディレクトリに「マウント」されます (Unix コマンドは <command>mount</command> と呼ばれます)。マウントされたディスクは「マウントポイント」の下から利用可能になります。これのお陰で、2 台目のハードディスクにユーザのホームディレクトリ (伝統的に <filename>/home/</filename> の中に保存されます) を保存する事が可能です。このディスクには <literal>rhertzog</literal> と <literal>rmas</literal> ディレクトリが含まれます。2 台目のハードディスクを <filename>/home/</filename> にマウントすると、ユーザのホームディレクトリの通常の場所からこれらのディレクトリにアクセス可能になり、<filename>/home/rmas/Desktop/hello.txt</filename> などのパスが動作するようになります。"

#. Tag: indexterm
#, no-c-format
msgid "<primary><command>mkfs</command></primary>"
msgstr "<primary><command>mkfs</command></primary>"

#. Tag: para
#, no-c-format
msgid "There are many filesystems, corresponding to many ways of physically storing data on disks. The most widely known are <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> and <emphasis>ext4</emphasis>, but others exist. For instance, <emphasis>vfat</emphasis> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <command>mkfs.ext3</command> (where <command>mkfs</command> stands for <emphasis>MaKe FileSystem</emphasis>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <filename>/dev/sda1</filename>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh."
msgstr "ディスク上に物理的にデータを保存する方法の違いに対応して、多くのファイルシステムが存在します。最も広く知られているファイルシステムは <emphasis>ext2</emphasis>、<emphasis>ext3</emphasis>、<emphasis>ext4</emphasis> ですが、他にも存在します。例えば、<emphasis>vfat</emphasis> は歴史的に DOS と Windows オペレーティングシステムで使われていたファイルシステムで、<emphasis>vfat</emphasis> ファイルシステムを使っているハードディスクは Debian および Windows の下で使う事が可能です。いかなる場合でも、ディスクをマウントする前に必ずディスク上にファイルシステムを準備しなければいけません。この準備作業は「フォーマット」として知られています。フォーマットを行うには <command>mkfs.ext3</command> (ここで <command>mkfs</command> は <emphasis>MaKe FileSystem</emphasis> の略語です) などのコマンドを使います。<command>mkfs</command> コマンドには、フォーマットされるパーティションを指すデバイスファイル (例えば <filename>/dev/sda1</filename>) をパラメータとして渡す必要があります。ファイルシステムの作成作業は破壊的なものです。意図的にファイルシステムを完全消去して、最初からやり直したい場合を除いて、2 回やってはいけません。"

#. Tag: para
#, no-c-format
msgid "There are even network filesystems, such as <acronym>NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way."
msgstr "更に、<acronym>NFS</acronym> などのネットワークファイルシステムが存在します。ネットワークファイルシステムを使った場合、データはローカルディスクに保存されません。その代わり、データはネットワークを介してサーバに送信されます。サーバは要求に応じてデータを保存したり、読み出したりします。ファイルシステムを抽象化したことによるユーザが特に心がける点はありません: ファイルは通常の階層構造的方法を使ってアクセス可能です。"

#. Tag: title
#, no-c-format
msgid "Shared Functions"
msgstr "共有機能"

#. Tag: para
#, no-c-format
msgid "Since a number of the same functions are used by all software, it makes sense to centralize them in the kernel. For instance, shared filesystem handling allows any application to simply open a file by name, without needing to worry where the file is stored physically. The file can be stored in several different slices on a hard disk, or split across several hard disks, or even stored on a remote file server. Shared communication functions are used by applications to exchange data independently of the way the data is transported. For instance, transport could be over any combination of local or wireless networks, or over a telephone landline."
msgstr "数多くの同じ機能がすべてのソフトウェアで使われますから、これらの機能をカーネルに集中させることは合理的です。例えば、共有ファイルシステムを取り扱う機能を使うことで、名前から簡単にファイルを開く事が可能になります。ファイルが物理的に保存されている場所を気にする必要はありません。ファイルは 1 台のハードディスクの複数の異なる部分に保存したり、複数のハードディスクに渡って分割したり、リモートファイルサーバに保存する事が可能です。アプリケーションはデータを交換するために共有された通信機能を使います。アプリケーション側からするとデータを転送する方法を意識する必要はありません。例えば、データ転送はローカル、ワイヤレスネットワーク、固定電話回線の任意の組み合わせを通じて行われるかもしれません。"

#. Tag: indexterm
#, no-c-format
msgid "<primary><emphasis>pid</emphasis></primary>"
msgstr "<primary><emphasis>pid</emphasis></primary>"

#. Tag: para
#, no-c-format
msgid "A process is a running instance of a program. This requires memory to store both the program itself and its operating data. The kernel is in charge of creating and tracking them. When a program runs, the kernel first sets aside some memory, then loads the executable code from the filesystem into it, and then starts the code running. It keeps information about this process, the most visible of which is an identification number known as <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>)."
msgstr "プロセスとはプログラムの実行中インスタンスです。プロセスはプログラム自身とその動作データを保存するためのメモリを要求します。カーネルはプロセスの作成と追跡を担当します。プログラムが実行されると、カーネルは最初に幾らかのメモリを確保し、次にファイルシステムから確保したメモリに実行可能なコードを読み込み、次にコードの実行を開始します。カーネルはプロセスに関する情報を保持します。中でも最もよく知られている情報は <emphasis>pid</emphasis> (<emphasis>プロセス識別子</emphasis>) として知られる識別番号です。"

#. Tag: para
#, no-c-format
msgid "Unix-like kernels (including Linux), like most other modern operating systems, are able of “multi-tasking”. In other words, they allow running many processes “at the same time”. There's actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they're actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may lack in snappiness and user interactivity. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and more frequent time slices than low-priority processes."
msgstr "Unix 系カーネル (Linux を含めて) は、多くの他の現代的なオペレーティングシステムと同様、「マルチタスク」機能を備えています。言い換えれば、Unix 系カーネルは多くのプロセスを「同時に」実行する事が可能です。ある時点で動いているのは 1 つのプロセスだけですが、カーネルは時間を小さな単位に切り分け、順繰りにそれぞれのプロセスを実行します。これらの時分割単位は極めて短い (ミリ秒程度) ので、プロセスが並列実行されているような錯覚を起こさせます。しかし実際のところプロセスはある時間周期で活動しており、残りの時間は動いていません。カーネルの仕事はこの錯覚を保つためにスケジューリングメカニズムを調節し、同時にシステム全体の性能を最大化する事です。時分割単位が長すぎる場合、アプリケーションからの応答が遅れ、ユーザとの対話処理に支障をきたすかもしれません。短すぎる場合、タスク切り替えが頻繁に起こるようになり、システムは処理時間を損する事になります。プロセス優先度を使えば、時分割単位を微調整する事が可能です。優先度の高いプロセスは優先度の低いプロセスに比べて長くそしてより頻繁な時分割単位で実行されます。"

#. Tag: title
#, no-c-format
msgid "<emphasis>NOTE</emphasis> Multi-processor systems (and variants)"
msgstr "<emphasis>NOTE</emphasis> マルチプロセッサシステム (とその亜種)"

#. Tag: para
#, no-c-format
msgid "The restriction described here is only a corner case. The actual restriction is that there can only be one running process <emphasis>per processor core</emphasis> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes."
msgstr "ここで説明している制限はかなり珍しいケースです。実用上の制限としては、同時に実行されるプロセスの数が<emphasis>プロセッサのコア 1 つあたり</emphasis> 1 つという制限です。マルチプロセッサ、マルチコア、「ハイパースレッディング」システムを使うことで、複数のプロセスを並列実行する事が可能です。ここでも同じ時分割システムを使いますが、このシステムは利用可能なプロセッサコアよりも多くのプロセスを実行させるようなケースを取り扱う事が可能です。これは決して珍しいことではありません: ベースシステムはほとんど動いていませんが、ほとんど常時数十個の実行中プロセスを抱えています。"

#. Tag: para
#, no-c-format
msgid "Of course, the kernel allows running several independent instances of the same program. But each can only access its own time slices and memory. Their data thus remain independent."
msgstr "もちろん、カーネルは同じプログラムの複数の独立したインスタンスも取り扱う事が可能です。しかし各プロセスは自分自身以外の時分割基準とメモリにアクセスすることはできません。このため、プロセスごとのデータは独立に管理されています。"

#. Tag: title
#, no-c-format
msgid "Rights Management"
msgstr "権限管理"

#. Tag: para
#, no-c-format
msgid "Unix-like systems are also multi-user. They provide a rights management system that allows separate groups and users; it also allows choosing to permit or block actions based on permissions. The kernel manages, for each process, data allowing permission checking. Most of the time, this means the process' “identity” is the same as the user that started it. And the process is only able to take the actions allowed to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <xref linkend=\"sect.rights-management\" />)."
msgstr "Unix 系システムはマルチユーザに対応しています。Unix 系システムの提供する権限管理システムを使うことで、グループとユーザを別々に管理する事が可能です; さらに、パーミッションに基いて操作を許可したり拒否したりする事が可能です。カーネルがそれぞれのプロセスについてパーミッション確認用のデータを管理しています。ほとんどの場合、これはプロセスの「識別情報」はプロセスを起動したユーザと同じということ意味しています。そして、プロセスは自分を起動した所有者の可能な動作だけを実行吸う事が可能です。例えば、プロセスがファイルを開く前に、カーネルによってそのプロセスの識別情報がアクセスパーミッションを持つ事を確認されます (具体的な例についてのより詳しい情報は<xref linkend=\"sect.rights-management\" />をご覧ください)。"

#. Tag: indexterm
#, no-c-format
msgid "<primary>user space</primary>"
msgstr "<primary>ユーザ空間</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>kernel space</primary>"
msgstr "<primary>カーネル空間</primary>"

#. Tag: para
#, no-c-format
msgid "“User-space” refers to the runtime environment of normal (as opposed to kernel) processes. This does not necessarily mean these processes are actually started by users because a standard system routinely has several “daemon” processes running before the user even opens a session. Daemon processes are user-space processes."
msgstr "「ユーザ空間」とは通常 (カーネルに対して) プロセスの実行環境を意味します。「ユーザ空間」プロセスとは実際にユーザによって開始されたプロセスという意味ではありません。なぜなら、標準的なシステムでは、ユーザがセッションを開始する前から実行されている定期的に複数の「デーモン」プロセスが存在するからです。デーモンプロセスはユーザ空間プロセスです。"

#. Tag: indexterm
#, no-c-format
msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

#. Tag: para
#, no-c-format
msgid "When the kernel gets past its initialization phase, it starts the very first process, <command>init</command>. Process #1 alone is very rarely useful by itself, and Unix-like systems run with a whole lifecycle of processes."
msgstr "カーネルはその初期化終了後に、最初のプロセス <command>init</command> を開始します。最初のプロセス <command>init</command> はそれ自身が役に立つことはほとんどなく、Unix 系システムでは他の様々なプロセスが動いています。"

#. Tag: indexterm
#, no-c-format
msgid "<primary><emphasis>fork</emphasis></primary>"
msgstr "<primary><emphasis>フォーク</emphasis></primary>"

#. Tag: para
#, no-c-format
msgid "First of all, a process can clone itself (this is known as a <emphasis>fork</emphasis>). The kernel allocates a new, but identical, process memory space, and another process to use it. At this point in time, the only difference between these two processes is their <emphasis>pid</emphasis>. The new process is customarily called a child process, and the process whose <emphasis>pid</emphasis> doesn't change, is called the parent process."
msgstr "まず最初に、プロセスは自分自身を複製 (これは<emphasis>フォーク</emphasis>として知られています) する事が可能です。カーネルは全く同じプロセスを新しいメモリ空間に割り当てます。そして、複製したプロセスが複製されたプロセスを使います。この時点で、2 つのプロセスの違いは <emphasis>pid</emphasis> だけです。新しいプロセスは習慣的に子プロセスと呼ばれています。そして <emphasis>pid</emphasis> が変わらなかったプロセスは親プロセスと呼ばれています。"

#. Tag: para
#, no-c-format
msgid "Sometimes, the child process continues to lead its own life independently from its parent, with its own data copied from the parent process. In many cases, though, this child process executes another program. With a few exceptions, its memory is simply replaced by that of the new program, and execution of this new program begins. One of the very first actions of process number 1, for instance, is to duplicate itself (which means there are, for a tiny amount of time, two running copies of the same <command>init</command> process), but the child process is then replaced by the first system initialization script, usually <filename>/etc/init.d/rcS</filename>. This script, in turn, clones itself and runs several other programs. At some point, one process among <command>init</command>'s offspring starts a graphical interface for users to log in to (the actual sequence of events is described in more details in <xref linkend=\"sect.system-boot\" />)."
msgstr "しばしば、子プロセスは親プロセスからコピーされたデータを持った状態で、親プロセスから独立して引き続き実行されます。とはいえ、子プロセスは他のプログラムを実行する場合が多いです。この場合、いくつかの例外を除いて、子プロセスのメモリは単純に新しいプログラムで置き換えられ、新しいプログラムの実行が始まります。例えば、プロセス番号 1 の最も初期の挙動の 1 つは自分自身を複製する事ですが (これは、ごく僅かな時間ですが、同じ <command>init</command> プロセスの 2 つの実行コピーが存在する事を意味します)、子プロセスは最初のシステム初期化スクリプト <filename>/etc/init.d/rcS</filename> で置き換えられます。システム初期化スクリプトは自分自身の複製を取り、複数の他のプログラムを実行します。同時に、<command>init</command> の子プロセスの 1 つがログイン機能を提供するユーザ用のグラフィカルインターフェースを開始します(実際のイベントの順番は<xref linkend=\"sect.system-boot\" />に詳しく書かれています)。"

#. Tag: para
#, no-c-format
msgid "When a process finishes the task for which it was started, it terminates. The kernel then recovers the memory assigned to this process, and stops giving it slices of running time. The parent process is told about its child process being terminated, which allows a process to wait for the completion of a task it delegated to a child process. This behavior is plainly visible in command-line interpreters (known as <emphasis>shells</emphasis>). When a command is typed into a shell, the prompt only comes back when the execution of the command is over. Most shells allow for running the command in the background, it is a simple matter of adding an <userinput>&amp;</userinput> to the end of the command. The prompt is displayed again right away, which can lead to problems if the command needs to display data of its own."
msgstr "プロセスが開始時に設定されたタスクを完了したら、プロセスは終了します。その後、カーネルがこのプロセスに割り当てられたメモリを回収し、カーネルはプロセスに実行時間を与える事を停止します。親プロセスは子プロセスが終了したことについて通知を受けます。このお陰で、親プロセスは子プロセスに委託したタスクの完了を待つ事が可能になります。コマンドラインインタプリタ (<emphasis>シェル</emphasis>として知られています) ではこの挙動がはっきりと見えます。コマンドがシェルに入力された場合、コマンドの実行が終了するまでプロンプトは戻って来ません。ほとんどのシェルでは、コマンドをバックグラウンドで実行する事が可能です。これを行うには、コマンドの最後に <userinput>&amp;</userinput> を追加するだけです。この場合、プロンプトはすぐに戻ってきます。コマンドからデータが表示される場合、このやり方は問題を引き起こすかもしれません。"

#. Tag: title
#, no-c-format
msgid "Daemons"
msgstr "デーモン"

#. Tag: indexterm
#, no-c-format
msgid "<primary>daemon</primary>"
msgstr "<primary>デーモン</primary>"

#. Tag: para
#, no-c-format
msgid "A “daemon” is a process started automatically by the boot sequence. It keeps running (in the background) to perform maintenance tasks or provide services to other processes. This “background task” is actually arbitrary, and does not match anything particular from the system's point of view. They are simply processes, quite similar to other processes, which run in turn when their time slice comes. The distinction is only in the human language: a process that runs with no interaction with a user (in particular, without any graphical interface) is said to be running “in the background” or “as a daemon”."
msgstr "「デーモン」は起動シーケンスによって自動的に開始されるプロセスです。「デーモン」はメンテナンス作業を実行したり他のプロセスにサービスを提供するために (バックグラウンドで) 実行され続けます。ここで実際の「バックグラウンドタスク」はどんなものでも構いませんし、システムの観点から何か特別なタスクを意味しているわけではありません。簡単に言って「バックグラウンドタスク」はプロセスで、他のプロセスとよく似ており、自分に割り当てられたタイムスライスが来た時に動きます。プロセスの区別は人間の言葉に過ぎません: ユーザと対話せずに実行される (特にグラフィカルインターフェースを持たない) プロセスは「バックグラウンドで実行される」とか「デーモンとして実行される」などと表現されます。"

#. Tag: title
#, no-c-format
msgid "<emphasis>VOCABULARY</emphasis> Daemon, demon, a derogatory term?"
msgstr "<emphasis>VOCABULARY</emphasis> Daemon (守り神)、demon (悪魔)、中傷的用語?"

#. Tag: para
#, no-c-format
msgid "Although <emphasis>daemon</emphasis> term shares its Greek etymology with <emphasis>demon</emphasis>, the former does not imply diabolical evil, instead, it should be understood as a kind of helper spirit. This distinction is subtle enough in English; it's even worse in other languages where the same word is used for both meanings."
msgstr "<emphasis>daemon</emphasis> という用語はギリシャ神話の <emphasis>demon</emphasis> と起源を共にしているにも関わらず、<emphasis>daemon</emphasis> は暗に残虐な悪魔を意味しておらず、その代わりに <emphasis>daemon</emphasis> は守り神のようなものとして理解されています。この区別は英語ではかなりわかりにくいものです; 両方の意味を同じ言葉で表している他の言語ではもっとわかりにくいです。"

#. Tag: para
#, no-c-format
msgid "Several such daemons are described in detail in <xref linkend=\"unix-services\" />."
msgstr "このようなデーモンは<xref linkend=\"unix-services\" />で詳細に説明されています。"

#. Tag: title
#, no-c-format
msgid "Inter-Process Communications"
msgstr "プロセス間通信"

#. Tag: indexterm
#, no-c-format
msgid "<primary>IPC</primary>"
msgstr "<primary>IPC</primary>"

#. Tag: indexterm
#, no-c-format
msgid "<primary>Inter-Process Communications</primary>"
msgstr "<primary>プロセス間通信</primary>"

#. Tag: para
#, no-c-format
msgid "An isolated process, whether a daemon or an interactive application, is rarely useful on its own, which is why there are several methods allowing separate processes to communicate together, either to exchange data or to control one another. The generic term referring to this is <emphasis>inter-process communication</emphasis>, or IPC for short."
msgstr "デーモンでも対話的アプリケーションでも、単独のプロセスは便利ではありません。このため、異なるプロセス同士がデータを交換したり、相互に制御し合うための様々な通信方法があります。これを意味する一般的な用語が <emphasis>プロセス間通信</emphasis> 略して IPC です。"

#. Tag: para
#, no-c-format
msgid "The simplest IPC system is to use files. The process that wishes to send data writes it into a file (with a name known in advance), while the recipient only has to open the file and read its contents."
msgstr "最も簡単な IPC システムではファイルを使います。データ送信側のプロセスが送信内容をファイルに書き込み (事前にファイル名を決めておく必要があります)、受信側はファイルを開いてその内容を読むだけです。"

#. Tag: indexterm
#, no-c-format
msgid "<primary><emphasis>pipe</emphasis></primary>"
msgstr "<primary><emphasis>パイプ</emphasis></primary>"

#. Tag: para
#, no-c-format
msgid "In the case where one does not wish to store data on disk, one can use a <emphasis>pipe</emphasis>, which is simply an object with two ends; bytes written in one end are readable at the other. If the ends are controlled by separate processes, this leads to a simple and convenient inter-process communication channel. Pipes can be classified into two categories: named pipes, and anonymous pipes. A named pipe is represented by an entry on the filesystem (although the transmitted data is not stored there), so both processes can open it independently if the location of the named pipe is known beforehand. In cases where the communicating processes are related (for instance, a parent and its child process), the parent process can also create an anonymous pipe before forking, and the child inherits it. Both processes will then be able to exchange data through the pipe without needing the filesystem."
msgstr "データをディスクに保存したくないと思っている場合、<emphasis>パイプ</emphasis>を使う事が可能です。<emphasis>パイプ</emphasis>は 2 つの端を持つ単純なオブジェクトです; 片側に書き込まれたデータを逆側から読み出す事が可能です。パイプの一方の端が別のプロセスによって制御されている場合、これは単純で便利なプロセス間通信チャネルになります。パイプは 2 種類に分類分けされます: 名前付きパイプと無名パイプです。名前付きパイプはファイルシステム上のエントリによって表現されます (転送されたデータは保存されません)。事前に名前付きパイプの場所がわかっていれば、2 つのプロセスが独立に名前付きパイプを開く事が可能です。通信プロセス同士に関連性がある場合 (例えば、親と子プロセス)、親プロセスはフォークの前に無名パイプを作成し、子プロセスがこれを継承するだけで済みます。両方のプロセスはパイプを通じてデータを交換する事が可能です。ファイルシステムは必要ありません。"

#. Tag: title
#, no-c-format
msgid "<emphasis>IN PRACTICE</emphasis> A concrete example"
msgstr "<emphasis>IN PRACTICE</emphasis> 具体例"

#. Tag: para
#, no-c-format
msgid "Let's describe in some detail what happens when a complex command (a <emphasis>pipeline</emphasis>) is run from a shell. We assume we have a <command>bash</command> process (the standard user shell on Debian), with <emphasis>pid</emphasis> 4374; into this shell, we type the command: <command>ls | sort</command> ."
msgstr "それでは、複雑なコマンド (<emphasis>パイプライン</emphasis>) がシェルから実行された場合に何が起きるか詳しく説明しましょう。<emphasis>pid</emphasis> 4374 の <command>bash</command> プロセス (Debian の標準的なユーザシェル) があると仮定します; このシェルの中で、次のコマンドをタイプします: <command>ls | sort</command> 。"

#. Tag: para
#, no-c-format
msgid "The shell first interprets the command typed in. In our case, it understands there are two programs (<command>ls</command> and <command>sort</command>), with a data stream flowing from one to the other (denoted by the <userinput>|</userinput> character, known as <emphasis>pipe</emphasis>). <command>bash</command> first creates an unnamed pipe (which initially exists only within the <command>bash</command> process itself)."
msgstr "シェルは最初に入力されたコマンドを解釈します。今回の場合、シェルは 2 種類のプログラム (<command>ls</command> と <command>sort</command>) が存在して、一方からもう一方へ流れるデータストリームがある (<userinput>|</userinput> 文字によって表されます。これは<emphasis>パイプ</emphasis>としても知られています) と理解します。<command>bash</command> は最初に無名パイプ (これは <command>bash</command> プロセス自身の中だけに存在します) を作成します。"

#. Tag: para
#, no-c-format
msgid "Then the shell clones itself; this leads to a new <command>bash</command> process, with <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> are abstract numbers, and generally have no particular meaning). Process #4521 inherits the pipe, which means it is able to write in its “input” side; <command>bash</command> redirects its standard output stream to this pipe's input. Then it executes (and replaces itself with) the <command>ls</command> program, which lists the contents of the current directory. Since <command>ls</command> writes on its standard output, and this output has previously been redirected, the results are effectively sent into the pipe."
msgstr "その後、シェルは自分自身の複製を作ります; これは新しい <command>bash</command> プロセスで <emphasis>pid</emphasis> #4521 を持っています (<emphasis>pid</emphasis> は抽象的な数で、一般に特別な意味はありません)。プロセス #4521 はパイプを継承します。これは「入力」側に書き込む事が可能という事を意味しています; <command>bash</command> は自分の標準出力ストリームをパイプの入力にリダイレクトします。その後、<command>bash</command> は <command>ls</command> プログラムを実行します (さらに自分自身を置き換えます)。<command>ls</command> は現在のディレクトリの内容をリストします。<command>ls</command> の書き込み先は標準出力で、この出力は予めリダイレクトされていたため、結果はパイプに送られます。"

#. Tag: para
#, no-c-format
msgid "A similar operation happens for the second command: <command>bash</command> clones itself again, leading to a new <command>bash</command> process with pid #4522. Since it is also a child process of #4374, it also inherits the pipe; <command>bash</command> then connects its standard input to the pipe output, then executes (and replaces itself with) the <command>sort</command> command, which sorts its input and displays the results."
msgstr "2 番目のコマンドについても同様の操作が行われます: <command>bash</command> は再度自分自身の複製を作り、これにより pid #4522 の新しい <command>bash</command> プロセスが作成されます。pid #4522 の新しい <command>bash</command> プロセスは #4374 の子プロセスで、パイプを継承します; <command>bash</command> は自分の標準入力をパイプの出力に接続し、その後 <command>sort</command> コマンドを実行します (さらに自分自身を置き換えます)。<command>sort</command> コマンドは自分の入力をソートして結果を表示します。"

#. Tag: para
#, no-c-format
msgid "All the pieces of the puzzle are now set up: <command>ls</command> reads the current directory and writes the list of files into the pipe; <command>sort</command> reads this list, sorts it alphabetically, and displays the results. Processes numbers #4521 and #4522 then terminate, and #4374 (which was waiting for them during the operation), resumes control and displays the prompt to allow the user to type in a new command."
msgstr "これで、パズルのすべてのピースが揃った状態になります: <command>ls</command> は現在のディレクトリを読み込んで、ファイルのリストをパイプに書き込みます; <command>sort</command> はファイルのリストを読み込んで、アルファベット順にソートして、結果を表示します。プロセス番号 #4521 と #4522 は終了し、#4374 (操作中の他プロセスを待っていました) は制御を取り戻し、ユーザが新しいコマンドを入力するためのプロンプトを表示します。"

#. Tag: para
#, no-c-format
msgid "Not all inter-process communications are used to move data around, though. In many situations, the only information that needs to be transmitted are control messages such as “pause execution” or “resume execution”. Unix (and Linux) provides a mechanism known as <emphasis>signals</emphasis>, through which a process can simply send a signal (chosen within a fixed list of a few tens of predefined signals) to another process. The only requirement is to know the <emphasis>pid</emphasis> of the target."
msgstr "しかしながら、すべてのプロセス間通信がデータを移動させるために使われるわけではありません。多くの状況で、送信する必要のある情報は「実行を一時停止」や「実行を再開」などの制御メッセージです。Unix (と Linux) は <emphasis>シグナル</emphasis> として知られているメカニズムを提供します。このメカニズムを使って、プロセスは別のプロセスに対して簡単にシグナルを送信する事が可能です (送信するシグナルは事前に定義された数十個のシグナルのリストから選びます)。送信に必要な情報は送信先の <emphasis>pid</emphasis> だけです。"

#. Tag: para
#, no-c-format
msgid "For more complex communications, there are also mechanisms allowing a process to open access, or share, part of its allocated memory to other processes. Memory shared between them can be used to move data across."
msgstr "更に複雑な通信を行うには、プロセスが他のプロセスに対して自分が割り当てられたメモリの一部へのアクセスを開放したり、共有するメカニズムを使います。プロセス間のメモリ共有はデータを交換するために使われます。"

#. Tag: para
#, no-c-format
msgid "Finally, network connections can also help processes communicate; these processes can even be running on different computers, possibly thousands of kilometers apart."
msgstr "最後に、ネットワーク接続を使ってプロセス同士を通信させる事が可能です; 数千キロ離れた異なるコンピュータで動いているプロセス同士でも通信可能です。"

#. Tag: para
#, no-c-format
msgid "It is quite standard for a typical Unix-like system to make use of all these mechanisms to various degrees."
msgstr "典型的な Unix 系システムでは、様々なレベルでこれらのメカニズムを使っており、かなり標準的な手法になっています。"

#. Tag: title
#, no-c-format
msgid "Libraries"
msgstr "ライブラリ"

#. Tag: indexterm
#, no-c-format
msgid "<primary>library (of functions)</primary>"
msgstr "<primary>(関数) ライブラリ</primary>"

#. Tag: para
#, no-c-format
msgid "Function libraries play a crucial role in a Unix-like operating system. They are not proper programs, since they cannot be executed on their own, but collections of code fragments that can be used by standard programs. Among the common libraries, you can find:"
msgstr "関数ライブラリは Unix 系オペレーティングシステムで重要な役割を果たします。関数ライブラリは厳密な意味でプログラムではありません。なぜなら、関数ライブラリ自体は実行できず、ただのコードの断片に過ぎないからです。しかし、標準的なプログラムは関数ライブラリを使っています。共有ライブラリの中でも特に以下のものが有名です:"

#. Tag: para
#, no-c-format
msgid "the standard C library (<emphasis>glibc</emphasis>), which contains basic functions such as ones to open files or network connections, and others facilitating interactions with the kernel;"
msgstr "標準 C ライブラリ (<emphasis>glibc</emphasis>)、これにはファイルやネットワーク接続を開く関数やカーネルとの通信を容易にする関数などの基本的な関数が含まれます;"

#. Tag: para
#, no-c-format
msgid "graphical toolkits, such as Gtk+ and Qt, allowing many programs to reuse the graphical objects they provide;"
msgstr "Gtk+ と Qt などのグラフィカルツールキット、これを使うことで、多くのプログラムはツールキットの提供するグラフィカルオブジェクトを再利用する事が可能です;"

#. Tag: para
#, no-c-format
msgid "the <emphasis>libpng</emphasis> library, that allows loading, interpreting and saving images in the PNG format."
msgstr "<emphasis>libpng</emphasis> ライブラリ、これを使うことで、PNG フォーマットイメージを読み込み、編集、保存する事が可能になります。"

#. Tag: para
#, no-c-format
msgid "Thanks to those libraries, applications can reuse existing code. Their development is thus correspondingly simplified, in particular when many applications reuse the same functions. Since libraries are often developed by different persons, the global development of the system is closer to Unix's historical philosophy."
msgstr "これらのライブラリのお陰で、アプリケーションは既存のコードを再利用する事が可能です。これに応じて、アプリケーションの開発が簡単になります。多くのアプリケーションが同じ関数を再利用している場合、この傾向は特に顕著になります。通常ライブラリはアプリケーションとは別の人によって開発されているため、システムの大域的な開発は Unix の歴史的哲学に近いものです。"

#. Tag: title
#, no-c-format
msgid "<emphasis>CULTURE</emphasis> The Unix Way: one thing at a time"
msgstr "<emphasis>CULTURE</emphasis> Unix 流: 一度に一つの事をせよ"

#. Tag: para
#, no-c-format
msgid "One of the fundamental concepts that underlies the Unix family of operating systems is that each tool should only do one thing, and do it well; applications can then reuse these tools to build more advanced logic on top. This Way can be seen in many incarnations. Shell scripts may be the best example: they assemble complex sequences of very simple tools (such as <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> and so on). Another implementation of this philosophy can be seen in code libraries: the <emphasis>libpng</emphasis> library allows reading and writing PNG images, with different options and in different ways, but it does only that; no question of including functions that display or edit images."
msgstr "Unix 系オペレーティングシステムの根底にある基本的概念の一つとして、それぞれのツールがたった 1 つの事を担当し、それを上手くこなす、というものがあります; アプリケーションはこれらのツールを再利用して、より高度な論理をつくり上げる事が可能です。この基本的概念は様々な形で具現化されています。シェルスクリプトは最良の例かもしれません: シェルスクリプトは極めて簡単なツール (例えば <command>grep</command>、<command>wc</command>、<command>sort</command>、<command>uniq</command> など) を複雑に並べたものです。コードライブラリも基本的概念を具現化したものとして見る事が可能です: <emphasis>libpng</emphasis> ライブラリを使うことで、様々なオプションと様々な方法を使って、PNG イメージの読み込みと書き込みを行う事が可能です。しかし、<emphasis>libpng</emphasis> ライブラリはそれ以上の事を行いません; イメージを表示したり編集する関数は含まれません。"

#. Tag: para
#, no-c-format
msgid "Moreover, these libraries are often referred to as “shared libraries”, since the kernel is able to only load them into memory once, even if several processes use the same library at the same time. This allows saving memory, when compared with the opposite (hypothetical) situation where the code for a library would be loaded as many times as there are processes using it."
msgstr "さらに、これらのライブラリは「共有ライブラリ」とも呼ばれています。なぜなら、複数のプロセスが同じライブラリを同時に使う場合、カーネルはライブラルの読み込みを一回だけで済ませる事が可能だからです。プロセスが使うライブラリのコードを何度も読み込むような逆の (仮想的) 状況に比べて、これはメモリを節約することになります。"
